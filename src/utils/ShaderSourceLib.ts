export default {"skybox_frag.glsl":"#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform samplerCube u_samplerCube;\r\nvarying vec3 v_TexCood;\r\n\r\nvoid main() {\r\n    gl_FragColor = textureCube(u_samplerCube, v_TexCood);\r\n}","skybox_vert.glsl":"attribute vec3 a_Position;\r\n\r\nuniform mat4 u_ViewMatrix;\r\nuniform mat4 u_ProjMatrix;\r\n\r\nvarying vec3 v_TexCood;\r\n\r\nvoid main() {\r\n    vec4 pos = u_ProjMatrix * u_ViewMatrix * vec4(a_Position, 1.0);\r\n    \r\n    gl_Position = pos.xyww; \r\n    v_TexCood = a_Position;\r\n}","standard_gouraud_frag.glsl":"#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_sampler2d;  //2维纹理采样器\r\nvarying vec2 v_TexCood;  //片元纹理坐标\r\nvarying vec3 v_color;\r\n\r\nuniform bool u_HasTexture;\r\n\r\nvoid main() {\r\n    vec3 textureColor = vec3(1.0, 1.0, 1.0);\r\n    if (u_HasTexture) {\r\n        textureColor = vec3(texture2D(u_sampler2d, v_TexCood));\r\n    }\r\n    gl_FragColor = vec4(textureColor * v_color, 1.0);\r\n}\r\n","standard_gouraud_vert.glsl":"uniform mat4 u_mvMatrix;\r\nuniform mat4 u_ProjMatrix;\r\nuniform mat4 u_NormalMatrix;\r\n\r\nattribute vec4 a_Normal;\r\nattribute vec4 a_Position;\r\n\r\nstruct Material\r\n{\r\n    vec3 emissive; //自身光线放射系数\r\n    vec3 ambient;  //环境光\r\n    vec3 diffuse;  //漫反射系数\r\n    vec3 specular; //镜面反射系数\r\n    float shininess; //高光系数\r\n    float alpha; //透明度\r\n};\r\n\r\nstruct Light\r\n{\r\n    vec4 position; //对于点光源，w==1, 平行光源w==0\r\n    vec3 color; //光源颜色\r\n    float intensity; //光源强度系数\r\n\r\n    float scope; //对于点光源scope是有限的，平行光不设置\r\n    float attenuate; //衰减因子，对点光源有效\r\n\r\n    vec3 direction; // 聚光灯半轴方向\r\n    float theta; // 聚光灯半径边沿与半轴方向的夹角\r\n};\r\n\r\nconst int MAX_LIGHT_NUM = 8; //最大光源数\r\n\r\n//光源数组\r\nuniform Light lights[MAX_LIGHT_NUM];\r\n\r\n\r\n//渲染的面，1 正面  2背面  3双面\r\nuniform int side;\r\n\r\n//uniform Material frontMaterial; //正面材质\r\n//uniform Material backMaterial;  //背面材质\r\n//表面材质\r\n//Material material;\r\n\r\n\r\nuniform vec3 u_globalAmbient;\r\n\r\nuniform vec3 u_materialEmissive;\r\nuniform vec3 u_materialAmbient;\r\nuniform vec3 u_materialDiffuse;\r\nuniform vec3 u_materialSpecular;\r\nuniform float u_materialShiness;\r\n\r\n//varying vec3 v_ViewFragCood; //在视坐标系中，片元坐标\r\n//varying vec3 v_FragNormal;   //片元的法线，由顶点法线插值而来\r\nattribute vec2 a_TexCood;\r\nvarying vec2 v_TexCood;  //片元纹理坐标\r\n\r\nuniform int u_NumLight;\r\n\r\nuniform bool u_HasTexture;\r\n\r\nvarying vec3 v_color;\r\n\r\n\r\nvec3 calculateAmbientColor() {\r\n   if (u_HasTexture) {\r\n       return u_materialAmbient * u_globalAmbient;\r\n   }\r\n   return u_materialEmissive + u_materialAmbient * u_globalAmbient;\r\n}\r\n\r\n\r\nfloat lightIntensity(Light light, float distance) {\r\n    float att = 1.0 / pow(distance, 0.9) * light.attenuate;\r\n    return att * light.intensity;\r\n    //return light.intensity;\r\n}\r\n\r\nvec3 lighting(vec3 fragCoodInView, vec3 viewDirection, vec3 normal) {\r\n    //vec3 textureColor = vec3(1.0, 1.0, 1.0);\r\n    vec3 color = calculateAmbientColor();\r\n\r\n    for (int i = 0; i < MAX_LIGHT_NUM; i++) {\r\n        if (i >= u_NumLight) break; // 超过实际光源数量时，不再执行\r\n        Light light = lights[i];\r\n        bool isDirectionalLight = light.position.w == 0.0; // 是否平行光源\r\n        vec3 lightDirection = isDirectionalLight ? normalize( light.position.xyz ) :\r\n            normalize( light.position.xyz / light.position.w - fragCoodInView );\r\n        float angle = max(dot(lightDirection, normal), 0.0); // 光源方向和法线夹角\r\n        if (angle <= 0.0)continue; // 片元位于背光面， 不计算本光源的光照\r\n\r\n        float intensity = light.intensity;\r\n\r\n        if (!isDirectionalLight) {//点光源\r\n            float distance = distance(fragCoodInView, light.position.xyz);\r\n            if (distance > light.scope) continue; // 超出光源范围， 不计算本光源的光照\r\n            if (light.theta > 0.0) { // 聚光灯是点光源的特例\r\n                float fragTheta = dot(-lightDirection, normalize(light.direction)); // 片元与聚光灯方向的夹角\r\n                fragTheta = max(fragTheta, 0.0);\r\n                if (fragTheta < light.theta) continue; // 夹角过大，超出光源区域\r\n            }\r\n            intensity = lightIntensity(light, distance);\r\n        }\r\n\r\n        //漫反射分量，如果没有纹理，纹理颜色值默认是(1.0, 1.0, 1.0)，即乘以单位1，不变\r\n        color += angle * (intensity * u_materialDiffuse) * light.color;\r\n\r\n        //镜面反射分量\r\n        // Phong\r\n        \r\n\r\n        // Blinn-Phong\r\n        vec3 halfDirection = (viewDirection + lightDirection); // 视线方向和光源方向的二分夹角\r\n        float halfAngle = max(dot(normalize(halfDirection), normal), 0.0);\r\n        if (halfAngle == 0.0) continue;\r\n        color += pow(halfAngle, u_materialShiness) * (intensity * u_materialSpecular) * light.color;\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    \r\n\r\n    vec4 pos = u_ProjMatrix * u_mvMatrix * a_Position;\r\n    gl_Position = pos;\r\n    vec3 normal = (u_NormalMatrix * a_Normal).xyz;\r\n    if (side == 2 || side == 3)//背面或双面渲染\r\n    {\r\n        //if (!gl_FrontFacing)tnormal = -tnormal;\r\n    }\r\n    v_color = lighting(pos.xyz, normalize(-pos).xyz, normalize(normal));\r\n    if (u_HasTexture) {\r\n        v_TexCood = a_TexCood;\r\n    }\r\n}\r\n","standard_phong_frag.glsl":"#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nstruct Material\r\n{\r\n    vec3 emissive; //自身光线放射系数\r\n    vec3 ambient;  //环境光\r\n    vec3 diffuse;  //漫反射系数\r\n    vec3 specular; //镜面反射系数\r\n    float shininess; //高光系数\r\n    float alpha; //透明度\r\n};\r\n\r\nstruct Light\r\n{\r\n    vec4 position; //对于点光源，w==1, 平行光源w==0\r\n    vec3 color; //光源颜色\r\n    float intensity; //光源强度系数\r\n\r\n    float scope; //对于点光源scope是有限的，平行光不设置\r\n    float attenuate; //衰减因子，对点光源有效\r\n\r\n    vec3 direction; // 聚光灯半轴方向\r\n    float theta; // 聚光灯半径边沿与半轴方向的夹角\r\n};\r\n\r\nconst int MAX_LIGHT_NUM = 8; //最大光源数\r\n\r\n//光源数组\r\nuniform Light lights[MAX_LIGHT_NUM];\r\n\r\n\r\n//渲染的面，1 正面  2背面  3双面\r\nuniform int side;\r\n\r\n//uniform Material frontMaterial; //正面材质\r\n//uniform Material backMaterial;  //背面材质\r\n//表面材质\r\n//Material material;\r\n\r\n\r\nuniform vec3 u_globalAmbient;\r\n\r\nuniform vec3 u_materialEmissive;\r\nuniform vec3 u_materialAmbient;\r\nuniform vec3 u_materialDiffuse;\r\nuniform vec3 u_materialSpecular;\r\nuniform float u_materialShiness;\r\n\r\nvarying vec3 v_ViewFragCood; //在视坐标系中，片元坐标\r\nvarying vec3 v_FragNormal;   //片元的法线，由顶点法线插值而来\r\n\r\nuniform sampler2D u_sampler2d;  //2维纹理采样器\r\nvarying vec2 v_TexCood;  //片元纹理坐标\r\n\r\nuniform int u_NumLight;\r\n\r\nuniform bool u_HasTexture;\r\n\r\n\r\nvec3 calculateAmbientColor(inout vec3 textureColor) {\r\n   if (u_HasTexture) {\r\n       textureColor = vec3(texture2D(u_sampler2d, v_TexCood));\r\n   }\r\n   vec3 color = u_materialEmissive + textureColor * u_materialAmbient * u_globalAmbient;//无纹理环境光反射\r\n   return color;\r\n}\r\n\r\n\r\nfloat lightIntensity(Light light, float distance) {\r\n    float att = 1.0 / pow(distance, 0.9) * light.attenuate;\r\n    return att * light.intensity;\r\n    //return light.intensity;\r\n}\r\n\r\nvec3 lighting(vec3 fragCoodInView, vec3 viewDirection, vec3 normal) {\r\n    vec3 textureColor = vec3(1.0, 1.0, 1.0);\r\n    vec3 color = calculateAmbientColor(textureColor);\r\n\r\n    for (int i = 0; i < MAX_LIGHT_NUM; i++) {\r\n        if (i >= u_NumLight) break; // 超过实际光源数量时，不再执行\r\n        Light light = lights[i];\r\n        bool isDirectionalLight = light.position.w == 0.0; // 是否平行光源\r\n        vec3 lightDirection = isDirectionalLight ? normalize( light.position.xyz ) :\r\n            normalize( light.position.xyz / light.position.w - fragCoodInView );\r\n        float angle = max(dot(lightDirection, normal), 0.0); // 光源方向和法线夹角\r\n        if (angle <= 0.0)continue; // 片元位于背光面， 不计算本光源的光照\r\n\r\n        float intensity = light.intensity;\r\n\r\n        if (!isDirectionalLight) {//点光源\r\n            float distance = distance(fragCoodInView, light.position.xyz);\r\n            if (distance > light.scope) continue; // 超出光源范围， 不计算本光源的光照\r\n            if (light.theta > 0.0) { // 聚光灯是点光源的特例\r\n                float fragTheta = dot(-lightDirection, normalize(light.direction)); // 片元与聚光灯方向的夹角\r\n                fragTheta = max(fragTheta, 0.0);\r\n                if (fragTheta < light.theta) continue; // 夹角过大，超出光源区域\r\n            }\r\n            intensity = lightIntensity(light, distance);\r\n        }\r\n\r\n        //漫反射分量，如果没有纹理，纹理颜色值默认是(1.0, 1.0, 1.0)，即乘以单位1，不变\r\n        color += textureColor * angle * (intensity * u_materialDiffuse) * light.color;\r\n\r\n        //镜面反射分量\r\n        // Phong\r\n        \r\n\r\n        // Blinn-Phong\r\n        vec3 halfDirection = (viewDirection + lightDirection); // 视线方向和光源方向的二分夹角\r\n        float halfAngle = max(dot(normalize(halfDirection), normal), 0.0);\r\n        if (halfAngle == 0.0) continue;\r\n        color += textureColor * pow(halfAngle, u_materialShiness) * (intensity * u_materialSpecular) * light.color;\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 tnormal = normalize(v_FragNormal);\r\n    if (side == 2 || side == 3)//背面或双面渲染\r\n    {\r\n        if (!gl_FrontFacing)tnormal = -tnormal;\r\n    }\r\n    gl_FragColor = vec4(lighting(v_ViewFragCood, normalize(-v_ViewFragCood), tnormal), 1.0);\r\n}\r\n","standard_phong_vert.glsl":"uniform mat4 u_mvMatrix;\r\nuniform mat4 u_ProjMatrix;\r\nuniform mat4 u_NormalMatrix;\r\n\r\nattribute vec4 a_Normal;\r\nattribute vec4 a_Position;\r\n\r\nvarying vec3 v_ViewFragCood;\r\nvarying vec3 v_FragNormal;\r\n\r\n//纹理\r\nattribute vec2 a_TexCood;\r\nvarying vec2 v_TexCood;\r\n\r\nuniform bool u_HasTexture;\r\n\r\nvoid main()\r\n{\r\n    vec4 modelViewCood = u_mvMatrix * a_Position;\r\n    gl_Position = u_ProjMatrix * modelViewCood;\r\n    v_FragNormal = (u_NormalMatrix * a_Normal).xyz;\r\n    v_ViewFragCood = modelViewCood.xyz;\r\n    if (u_HasTexture) {\r\n        v_TexCood = a_TexCood;\r\n    }\r\n}\r\n"}