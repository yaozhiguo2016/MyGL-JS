export default {"cubemap_frag.glsl":"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform samplerCube texMap;\nvarying vec3 v_TexCood;\nvoid main()\n{\n    vec4 color = textureCube(texMap, v_TexCood);\n    gl_FragColor = color;\n}","cubemap_vert.glsl":"uniform mat4 u_MvpMatrix;\nattribute vec4 a_Position;\nvarying vec3 v_TexCood;\nvoid main()\n{\n    gl_Position = u_MvpMatrix * a_Position;\n    v_TexCood = a_Position.xyz;\n}","standard_gouraud_frag.glsl":"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D u_sampler2d;  varying vec2 v_TexCood;  varying vec3 v_color;\nuniform bool u_HasTexture;\nvoid main() {\n    vec3 textureColor = vec3(1.0, 1.0, 1.0);\n    if (u_HasTexture) {\n        textureColor = vec3(texture2D(u_sampler2d, v_TexCood));\n    }\n    gl_FragColor = vec4(textureColor * v_color, 1.0);\n}\n","standard_gouraud_vert.glsl":"uniform mat4 u_mvMatrix;\nuniform mat4 u_ProjMatrix;\nuniform mat4 u_NormalMatrix;\nattribute vec4 a_Normal;\nattribute vec4 a_Position;\nstruct Material\n{\n    vec3 emissive;     vec3 ambient;      vec3 diffuse;      vec3 specular;     float shininess;     float alpha; };\nstruct Light\n{\n    vec4 position;     vec3 color;     float intensity; \n    float scope;     float attenuate; \n    vec3 direction;     float theta; };\nconst int MAX_LIGHT_NUM = 8; \nuniform Light lights[MAX_LIGHT_NUM];\nuniform int side;\nuniform vec3 u_globalAmbient;\nuniform vec3 u_materialEmissive;\nuniform vec3 u_materialAmbient;\nuniform vec3 u_materialDiffuse;\nuniform vec3 u_materialSpecular;\nuniform float u_materialShiness;\nattribute vec2 a_TexCood;\nvarying vec2 v_TexCood;  \nuniform int u_NumLight;\nuniform bool u_HasTexture;\nvarying vec3 v_color;\nvec3 calculateAmbientColor() {\n   if (u_HasTexture) {\n       return u_materialAmbient * u_globalAmbient;\n   }\n   return u_materialEmissive + u_materialAmbient * u_globalAmbient;\n}\nfloat lightIntensity(Light light, float distance) {\n    float att = 1.0 / pow(distance, 0.9) * light.attenuate;\n    return att * light.intensity;\n    }\nvec3 lighting(vec3 fragCoodInView, vec3 viewDirection, vec3 normal) {\n        vec3 color = calculateAmbientColor();\n    for (int i = 0; i < MAX_LIGHT_NUM; i++) {\n        if (i >= u_NumLight) break;         Light light = lights[i];\n        bool isDirectionalLight = light.position.w == 0.0;         vec3 lightDirection = isDirectionalLight ? normalize( light.position.xyz ) :\n            normalize( light.position.xyz / light.position.w - fragCoodInView );\n        float angle = max(dot(lightDirection, normal), 0.0);         if (angle <= 0.0)continue; \n        float intensity = light.intensity;\n        if (!isDirectionalLight) {            float distance = distance(fragCoodInView, light.position.xyz);\n            if (distance > light.scope) continue;             if (light.theta > 0.0) {                 float fragTheta = dot(-lightDirection, normalize(light.direction));                 fragTheta = max(fragTheta, 0.0);\n                if (fragTheta < light.theta) continue;             }\n            intensity = lightIntensity(light, distance);\n        }\n                color += angle * (intensity * u_materialDiffuse) * light.color;\n                        \n                vec3 halfDirection = (viewDirection + lightDirection);         float halfAngle = max(dot(normalize(halfDirection), normal), 0.0);\n        if (halfAngle == 0.0) continue;\n        color += pow(halfAngle, u_materialShiness) * (intensity * u_materialSpecular) * light.color;\n    }\n    return color;\n}\nvoid main()\n{\n    \n    vec4 pos = u_ProjMatrix * u_mvMatrix * a_Position;\n    gl_Position = pos;\n    vec3 normal = (u_NormalMatrix * a_Normal).xyz;\n    if (side == 2 || side == 3)    {\n            }\n    v_color = lighting(pos.xyz, normalize(-pos).xyz, normalize(normal));\n    if (u_HasTexture) {\n        v_TexCood = a_TexCood;\n    }\n}\n","standard_phong_frag.glsl":"#ifdef GL_ES\nprecision mediump float;\n#endif\nstruct Material\n{\n    vec3 emissive;     vec3 ambient;      vec3 diffuse;      vec3 specular;     float shininess;     float alpha; };\nstruct Light\n{\n    vec4 position;     vec3 color;     float intensity; \n    float scope;     float attenuate; \n    vec3 direction;     float theta; };\nconst int MAX_LIGHT_NUM = 8; \nuniform Light lights[MAX_LIGHT_NUM];\nuniform int side;\nuniform vec3 u_globalAmbient;\nuniform vec3 u_materialEmissive;\nuniform vec3 u_materialAmbient;\nuniform vec3 u_materialDiffuse;\nuniform vec3 u_materialSpecular;\nuniform float u_materialShiness;\nvarying vec3 v_ViewFragCood; varying vec3 v_FragNormal;   \nuniform sampler2D u_sampler2d;  varying vec2 v_TexCood;  \nuniform int u_NumLight;\nuniform bool u_HasTexture;\nvec3 calculateAmbientColor(inout vec3 textureColor) {\n   if (u_HasTexture) {\n       textureColor = vec3(texture2D(u_sampler2d, v_TexCood));\n   }\n   vec3 color = u_materialEmissive + textureColor * u_materialAmbient * u_globalAmbient;   return color;\n}\nfloat lightIntensity(Light light, float distance) {\n    float att = 1.0 / pow(distance, 0.9) * light.attenuate;\n    return att * light.intensity;\n    }\nvec3 lighting(vec3 fragCoodInView, vec3 viewDirection, vec3 normal) {\n    vec3 textureColor = vec3(1.0, 1.0, 1.0);\n    vec3 color = calculateAmbientColor(textureColor);\n    for (int i = 0; i < MAX_LIGHT_NUM; i++) {\n        if (i >= u_NumLight) break;         Light light = lights[i];\n        bool isDirectionalLight = light.position.w == 0.0;         vec3 lightDirection = isDirectionalLight ? normalize( light.position.xyz ) :\n            normalize( light.position.xyz / light.position.w - fragCoodInView );\n        float angle = max(dot(lightDirection, normal), 0.0);         if (angle <= 0.0)continue; \n        float intensity = light.intensity;\n        if (!isDirectionalLight) {            float distance = distance(fragCoodInView, light.position.xyz);\n            if (distance > light.scope) continue;             if (light.theta > 0.0) {                 float fragTheta = dot(-lightDirection, normalize(light.direction));                 fragTheta = max(fragTheta, 0.0);\n                if (fragTheta < light.theta) continue;             }\n            intensity = lightIntensity(light, distance);\n        }\n                color += textureColor * angle * (intensity * u_materialDiffuse) * light.color;\n                        \n                vec3 halfDirection = (viewDirection + lightDirection);         float halfAngle = max(dot(normalize(halfDirection), normal), 0.0);\n        if (halfAngle == 0.0) continue;\n        color += textureColor * pow(halfAngle, u_materialShiness) * (intensity * u_materialSpecular) * light.color;\n    }\n    return color;\n}\nvoid main()\n{\n    vec3 tnormal = normalize(v_FragNormal);\n    if (side == 2 || side == 3)    {\n        if (!gl_FrontFacing)tnormal = -tnormal;\n    }\n    gl_FragColor = vec4(lighting(v_ViewFragCood, normalize(-v_ViewFragCood), tnormal), 1.0);\n}\n","standard_phong_vert.glsl":"uniform mat4 u_mvMatrix;\nuniform mat4 u_ProjMatrix;\nuniform mat4 u_NormalMatrix;\nattribute vec4 a_Normal;\nattribute vec4 a_Position;\nvarying vec3 v_ViewFragCood;\nvarying vec3 v_FragNormal;\nattribute vec2 a_TexCood;\nvarying vec2 v_TexCood;\nuniform bool u_HasTexture;\nvoid main()\n{\n    vec4 modelViewCood = u_mvMatrix * a_Position;\n    gl_Position = u_ProjMatrix * modelViewCood;\n    v_FragNormal = (u_NormalMatrix * a_Normal).xyz;\n    v_ViewFragCood = modelViewCood.xyz;\n    if (u_HasTexture) {\n        v_TexCood = a_TexCood;\n    }\n}\n"}