export default {"cubemap_frag.glsl":"#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform samplerCube texMap;\r\nvarying vec3 v_TexCood;\r\n\r\nvoid main()\r\n{\r\n    vec4 color = textureCube(texMap, v_TexCood);\r\n    gl_FragColor = color;\r\n}","cubemap_vert.glsl":"uniform mat4 u_MvpMatrix;\r\n\r\nattribute vec4 a_Position;\r\nvarying vec3 v_TexCood;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = u_MvpMatrix * a_Position;\r\n    v_TexCood = a_Position.xyz;\r\n}","phong_frag.glsl":"#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nstruct Material\r\n{\r\n    vec3 emissive;\r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n    float shininess;\r\n    float alpha;\r\n};\r\n\r\nstruct Light\r\n{\r\n    vec4 position; //对于点光源，w==1, 平行光源w==0\r\n    vec3 color;\r\n    vec3 intensity;\r\n    bool enabled;\r\n\r\n    float scope;//对于点光源scope是有限的，平行光不设置\r\n    float attenuate; //衰减因子，对点光源有效\r\n};\r\n\r\nconst int MAX_LIGHT_NUM = 8;\r\n\r\n//光源数组\r\nuniform Light lights[MAX_LIGHT_NUM];\r\n//表面材质\r\nMaterial material;\r\n\r\n//渲染的面，1 正面  2背面  3双面\r\nuniform int side;\r\n\r\nuniform Material frontMaterial;\r\nuniform Material backMaterial;\r\n\r\n\r\nuniform vec3 globalAmbient;\r\n\r\nuniform vec3 materialEmissive;\r\nuniform vec3 materialAmbient;\r\nuniform vec3 materialDiffuse;\r\nuniform vec3 materialSpecular;\r\nuniform float materialShiness;\r\n\r\nvarying vec3 v_ViewFragCood;\r\nvarying vec3 v_FragNormal;\r\n\r\nuniform sampler2D u_sampler2d;\r\nvarying vec2 v_TexCood;\r\n\r\nvec3 lighting(vec3 fragCoodInView, vec3 viewDirection, vec3 normal)\r\n{\r\n    vec3 textureColor = vec3(texture2D(u_sampler2d, v_TexCood));\r\n    vec3 color = textureColor * materialAmbient * globalAmbient;//环境光反射\r\n\r\n    for (int i = 0; i < 2; i++)\r\n    {\r\n        Light light = lights[i];\r\n\r\n        //光源关闭\r\n        if (!light.enabled) continue;\r\n\r\n        //color += textureColor * materialAmbient * light.color;\r\n        vec3 lightDirection;\r\n        if (light.position.w == 0.0)//平行光源\r\n        {\r\n            lightDirection = normalize( light.position.xyz );\r\n        }\r\n        else //点光源\r\n        {\r\n            lightDirection = normalize( light.position.xyz / light.position.w - fragCoodInView );\r\n        }\r\n        float angle = max(dot(lightDirection, normal), 0.0);\r\n\r\n        if (angle <= 0.0)continue;\r\n        //漫反射分量\r\n        color += textureColor * angle * (light.intensity * materialDiffuse) * light.color;\r\n\r\n        //镜面反射方向\r\n        vec3 reflectDirection = (2.0 * angle) * normal - lightDirection;\r\n        float VRAngle = max(dot(viewDirection, reflectDirection), 0.0);\r\n        if (VRAngle <= 0.0)continue;\r\n        color += pow(VRAngle, materialShiness) * (light.intensity * materialSpecular) * light.color;\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 tnormal = normalize(v_FragNormal);\r\n    if (side == 2 || side == 3)//back side and double\r\n    {\r\n        if (!gl_FrontFacing)tnormal = -tnormal;\r\n    }\r\n    gl_FragColor = vec4(lighting(v_ViewFragCood, normalize(-v_ViewFragCood), tnormal), 1.0);\r\n}","phong_frag_no_texture.glsl":"#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nstruct Material\r\n{\r\n    vec3 emissive;\r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n    float shininess;\r\n    float alpha;\r\n};\r\n\r\nstruct Light\r\n{\r\n    vec4 position; //对于点光源，w==1, 平行光源w==0\r\n    vec3 color;\r\n    vec3 intensity;\r\n    bool enabled;\r\n\r\n    float scope;//对于点光源scope是有限的，平行光不设置\r\n    float attenuate; //衰减因子，对点光源有效\r\n};\r\n\r\nconst int MAX_LIGHT_NUM = 8;\r\n\r\n//光源数组\r\nuniform Light lights[MAX_LIGHT_NUM];\r\n//表面材质\r\nMaterial material;\r\n\r\n//渲染的面，1 正面  2背面  3双面\r\nuniform int side;\r\n\r\nuniform Material frontMaterial;\r\nuniform Material backMaterial;\r\n\r\n\r\nuniform vec3 globalAmbient;\r\n\r\nuniform vec3 materialEmissive;\r\nuniform vec3 materialAmbient;\r\nuniform vec3 materialDiffuse;\r\nuniform vec3 materialSpecular;\r\nuniform float materialShiness;\r\n\r\nvarying vec3 v_ViewFragCood;\r\nvarying vec3 v_FragNormal;\r\n\r\nvec3 lighting(vec3 fragCoodInView, vec3 viewDirection, vec3 normal)\r\n{\r\n    vec3 color = materialEmissive + materialAmbient * globalAmbient;//环境光反射\r\n\r\n    for (int i = 0; i < 2; i++)\r\n    {\r\n        Light light = lights[i];\r\n\r\n        //光源关闭\r\n        if (!light.enabled) continue;\r\n\r\n        color += materialAmbient * light.color;\r\n        vec3 lightDirection;\r\n        if (light.position.w == 0.0)//平行光源\r\n        {\r\n            lightDirection = normalize( light.position.xyz );\r\n        }\r\n        else //点光源\r\n        {\r\n            lightDirection = normalize( light.position.xyz / light.position.w - fragCoodInView );\r\n        }\r\n        float angle = max(dot(lightDirection, normal), 0.0);\r\n\r\n        if (angle <= 0.0)continue;\r\n        //漫反射分量\r\n        color += angle * (light.intensity * materialDiffuse) * light.color;\r\n\r\n        //镜面反射方向\r\n        vec3 reflectDirection = (2.0 * angle) * normal - lightDirection;\r\n        float VRAngle = max(dot(viewDirection, reflectDirection), 0.0);\r\n        if (VRAngle <= 0.0)continue;\r\n        color += pow(VRAngle, materialShiness) * (light.intensity * materialSpecular) * light.color;\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 tnormal = normalize(v_FragNormal);\r\n    if (side == 2 || side == 3)//back side and double\r\n    {\r\n        if (!gl_FrontFacing)tnormal = -tnormal;\r\n    }\r\n    gl_FragColor = vec4(lighting(v_ViewFragCood, normalize(-v_ViewFragCood), tnormal), 1.0);\r\n}","phong_vert.glsl":"uniform mat4 u_mvMatrix;\r\nuniform mat4 u_ProjMatrix;\r\nuniform mat4 u_NormalMatrix;\r\n\r\nattribute vec4 a_Normal;\r\nattribute vec4 a_Position;\r\n\r\nvarying vec3 v_ViewFragCood;\r\nvarying vec3 v_FragNormal;\r\n\r\n//纹理\r\nattribute vec2 a_TexCood;\r\nvarying vec2 v_TexCood;\r\n\r\nvoid main()\r\n{\r\n    vec4 modelViewCood = u_mvMatrix * a_Position;\r\n    gl_Position = u_ProjMatrix * modelViewCood;\r\n    v_FragNormal = (u_NormalMatrix * a_Normal).xyz;\r\n    v_ViewFragCood = modelViewCood.xyz;\r\n    v_TexCood = a_TexCood;\r\n}","phong_vert_no_texture.glsl":"uniform mat4 u_mvMatrix;\r\nuniform mat4 u_ProjMatrix;\r\nuniform mat4 u_NormalMatrix;\r\n\r\nattribute vec4 a_Normal;\r\nattribute vec4 a_Position;\r\n\r\nvarying vec3 v_ViewFragCood;\r\nvarying vec3 v_FragNormal;\r\n\r\nvoid main()\r\n{\r\n    vec4 modelViewCood = u_mvMatrix * a_Position;\r\n    gl_Position = u_ProjMatrix * modelViewCood;\r\n    v_FragNormal = (u_NormalMatrix * a_Normal).xyz;\r\n    v_ViewFragCood = modelViewCood.xyz;\r\n}"}